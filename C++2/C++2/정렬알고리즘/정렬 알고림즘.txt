1. 시간  복잡도란 ?
 - 문제를 해결하는데 걸리는 시간과 입력한 문제의 크기(N)과의 관계
 - 연산자의 숫자나 연산과정의 수를 합해서 계산
 - 시간복잡도 수치가 작을수록 효율적인 알고리즘

 2. 시간복잡도 표기법
 -big -O표기법  - 최악의 상황  ex)O(N) 
 -big-Omega표기법 -최고의 상황 ex)Ω(N)
 -theta표기법 -평균적인 상황   ex)Θ(N)

 3. 시간복잡도의 종류
 이름			복잡도
 상수형        0(1) : 데이터 수와 상관없이 '연산횟수가 고정'인 유형의 알고리즘
 로그형       O(logn) : '데이터 수의 증가율'에 비해 '연산회수의 증가율' 이 낮은 알고리즘
 선형         0(ㅜ) :데이터 수와 연산횟수가 비례하는 알고리즘 
 선형 로그형  O(nlogn) : 데이터 수가 증가 할 때 ,연산횟수가 조금 더 증가하는 알고리즘
 평방형       O(n^2) :데이터 수보다 연산횟수가 N배 더 많은 알고리즘(비추천)
 지수형		 O(2^n) :데이터 수가 N일때 연산횟수가 2^N인 알고리즘(비주천)
 계승형      O(n!) : 데이터 수가 N일때 연산횟수가 N!인 알고리즘(비추천)


 4. 시간 복잡도 구할 때의 규칙
 -상수항이나 영향력 없는 항은 무시
 
 1.상수항 무시 
 O(2N) , O(N=2) ->   0(N)

 2.영향력이 없는 항 무시
 O(N^2+N) -> O(N^2)

 5.시간 복잡도 구하기
 -1~N까지의 합계를 더하는 함수의 시간복잡도 구하기

 int Sum(int N)
 {
	int res =0;  // 1번 수행 

	for(int i  = 1; i<=N ; i++ )
	res +=i; // N번 수행된 
	
	return res;;
 }
 // 시간 복잡도
 T(N) = N+1

 6. 선택 정렬
 -제자리 정렬 알고리즘(추가 메모리를 요구하지 않음)
 -i번째 요소 i~N번째 요소 중 가장 작은 값을 넣고 , i를 증가 시키는 알고리즘

 3,5,4,1,2
 // 3과 가장 작은 1을 교환
 1,5,4,3,2 
 // 5와  가장 작은 2를 교환
 1,2,4,3,5
 // 4와 가장 작은 3을 교환(정렬 완료)
 1,2,4,3,5

 시간 복잡도 
 -T(n) = (n-1) +(n+2) +...2+1 = O(n^2)

 공간 복잡도
 -O(n)

 7. 산입 정렬
 - 제자리 정렬 알고리즘 (추가 메모리를 요구하지 않음)
 - i번째 요소 앞에 있는 요소들과 크기를 비교한 후 적절한 자리에 삽입하는 알고리즘

 3,5,1,4,2 
 //3과 5를 비교(자리 변환 없음)
 3,5,1,4,2
 //1이 가장 작으므로 3앞에 삽임
 1,3,5,4,2
 // 3과 5사이에 4를 삽입
 1,3,4,5,2
 //1과 3사이에 2를 삽입(정렬 완료)
 1,2,3,4,5

 시간 복잡도
 -T(n) = 1+2+... (n-2)(n-1)= O(n^2)

 공간 복잡도
 -O(n)

 8. 버블 정렬 
 - 제자리 정렬 알고리즘(추가 메모리를 요구하지 않음)
 - 인접한 요소끼리 크기를 비교해 자리를 교환하고 가장 큰 값을 맨 뒤로 보내는 과정(스캔)을 반복해 정렬하는 알고리즘
 - 가장 큰 값을 맨 뒤로 보내는 작업을 스캔이라 함

 3,5,1,4,2
 //3과 5를 비교 (자리 변화 없음)
 3,5,1,4,2
 // 5와 1을 비교 ( 자리 교체)
 3,1,5,4,2
 //5와 4를 비교 (자리교체)
 3,1,4,5,2
 //5과2를 비교 (자리 / 1차 스캔 완료)
 3,1,4,2,5
 
 시간 복잡도
 -T(n) = (n-1) +(n-2) +...2+1 = O(n^2)

  공간 복잡도
 -O(n)

 9.병합 정렬
 - 분합정복법을 사용해서 정렬하는 알고리즘
 - 앞의 정렬들에 비해 코드는 상대적으로 복잡하지만 효율이 좋음
 - 최악의 상황일 때에도 시간 복잡도는 O(nologn) 이므로 큌 정렬 보다 빠름(평균적으로는 퀵 정렬이 더 빠름)

 9-1. 분합정복법 (Devide-And-Conquer) 이란?
 - 해결하려는 문제를 작은 크기의 동일한 문제들로 나눠 작은 문제부터 해결하면  합쳐나가는 방법

 9-2. 분할 정복법의 단계
 1. 분할 : 큰 문제를 작은 크기로 분할
 2. 정복 : 각각의 작은 문제들을 순환적으로 해결
 3. 합병 : 작은 문제들의 해를 합하여 큰 문제들의 해를 구함

 시간 복잡도
 -T(n) =T(n/2) + T(n/2) +n = O(nlogn)

 공간 복잡도
 -O(2n)

9-2 .병합 정렬 동작 방식
1. 분할 
- 배열 집합을 하나의 원소 단위 될 때 까지 분할(재귀함수 사용)

					3,5,1,4,2
			3,5				1,4,2
		3		5		1,4			2
		3		5		1  4		2

9-3. 병합 정렬 동작 방식
2. 병합 
- 분할 된 원소의 크기를 정렬하며 병합한다.
-left , right 인덱스 증가시키면서 작은 숫자 순서대로 값을 넣어줌

 3		5		1		4		2
 3		4		1 ,4			2
	3,5				1,2,4
		1,2,3,4,5

10 .퀵 정렬
- 제자리 정렬 알고리즘 (추가 메모리를 요구하지 않음)
- 분할 정복법을 사용해서 정렬하는 알고리즘
- 평군적으로 가장 빠른 정렬 방법 = Θ(nlogn)
- pivot을 기준으로 partition을 2rofh 나눠 파티션들을 다시 퀵 정렬함 (재귀호출)
- pivot값이 가장 작거나 큰 경우가 반복되는 최악의 상황이 된다면 , 시간 복잡도는 O(n^2)이됨
- median(중간값) 을 pivot으로 설정하면 불균등 분활 완한 가능

10-1 퀵 정렬 순서 

1. 정렬한 범위가 2개 이상 데이터라면 pivot설정 ,2개 미만이라면 빠져 나옴
2. left는 partition 가장 왼쪽 숫자 , right는 partition 가장 오른쪽 숫자로 설정
3. left가 pivot보다 작다면 인덱스 증가(반복문)
4. right가 pivot보다 크다면 인덱스 감소 (반복문)
5. left,right가 교차하지 않는다면 left와 right값을 교환후 ,left++,right--
6. left ,right가 교차했다면 교차한 곳을 기준으로 partition 분할 , 각 파티션 마다 1~6번 반복( 재귀함수)

시간 복잡도
- T(n) = (n-1) + (n-2) + .. +2+1 =O(n^2)

공간복잡도
-O(n)

10-2 퀵 정렬 원리				
 pivot보다 작은 값들					pivot보다 큰 값들
						<-	pivot  ->
5,3,1,8,3,7,6,2				10				15,13,12,20,18,17,11,25,22
		파티션 분할 후 피봇 다시 설정

pivot보다 작은 값들				pivot보다 큰 값들		pivot보다 작은 값들								pivot보다 큰 값들	
				<- pivot ->												<-pivot->
1,3,2,				5						9,7,6,8,10,15,13,12,11,			17			,18,11,25,22
												파티션 분할 후 피봇 다시 설정


10-3. 퀵 정렬 동작 방식 (중간값)

[원본]
3 ,		1,	  4  , 5 , 2
left		pivot		right

3 ,		1,	  4  , 5 , 2
	left	pivot		right

3 ,		1,	  4  , 5 , 2
			left		right

						pivot
3 ,		1,	  2 ,	5 ,	 4
				left    right

					  pivot
3 ,		1,	  2	 , 5 , 4
			right left

	pivot	 파티셔 분할pivot
3 ,		1,	  2	 , 5 , 4
left		right left right

	pivot
3 ,		1,	  2	 , 5 , 4
left     right    right
pivot
1 ,		3,	  2	 , 4,	5
 right left		

     pivot
1,		3,	  2	 , 5 , 4
	 left		right